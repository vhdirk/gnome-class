#![feature(proc_macro)]
#![recursion_limit = "512"]
// While under active devel, these warnings are kind of annoying.
#![allow(dead_code)]

#[macro_use]
extern crate error_chain;
// extern crate lalrpop_intern;
// extern crate lalrpop_util;
#[macro_use]
extern crate quote;
extern crate proc_macro;
extern crate proc_macro2;
extern crate rustfmt;
extern crate unicode_xid;

#[macro_use]
extern crate syn;

extern crate glib_sys;
extern crate gobject_sys;

use errors::*;
use proc_macro::TokenStream;
use std::error::Error;

macro_rules! quote_cs {
    ($($tt:tt)*) => (quote_spanned!(::proc_macro2::Span::call_site()=>
                                    $($tt)*))
}

mod ast;
mod checking;
mod errors;
mod gen;
mod glib_utils;
mod hir;
mod param;
mod parser;

/// Generates the code to create a derived glib::Object
///
/// This procedural macro defines an extension to the Rust language so
/// that one can create GObjects using only safe code.  All the
/// boilerplate needed to register the GObject type, its signals and
/// properties, etc., is automatically generated.
///
/// # Syntax overview {#syntax-overview}
///
/// The macro is invoked as follows:
///
/// ```norun
/// #[macro_use]
/// extern crate glib;  // see "Necessary imports" below on why this is needed
/// use gobject_gen::gobject_gen;
///
/// gobject_gen! {
///     class Foo {
///         private_field: Cell<u32>,
///     }
///
///     // Methods and signals;, their order defines the ABI of your class
///     impl Foo {
///         pub fn a_static_method(&self) {
///             // self.get_priv() gives us access to the private
                // fields declared in class Foo
///             do_something_with_u32(self.get_priv().private_field.get());
///         }
///
///         virtual fn a_virtual_method(&self) {
///             // default handler implementation goes here
///         }
///
///         signal fn clicked(&self);
///     }
/// }
/// ```
///
/// Read on for the details on how to use GObject features.
///
/// # Instance-private data
///
/// GObject classes defined through this macro can have  instance-private data
/// declared as struct fields inside the class.
///
/// * **Declaration:** Declare struct fields inside `class Foo { ... }`
///
/// * **Initialization:** Implement the `Default` trait for your
/// struct members, either with `#[derive(Default)]` or with an `impl Default`
/// if its missing. Note that you have to do this for each type used across
/// fields. When the generated code needs to initialize the instance-private
/// data, it will do so by calling the `Default::default()` method and assign it
/// to the internally private structure generated by the macro.
///
/// * **Drop:** When the GObject instance gets finalized, your private
/// data will be `drop()`ed.  You can provide `impl Drop` for any fields
/// that need explicit resource management.
///
/// ## Example: instance-private data with default values
///
/// ```norun
/// #[derive(Default)]
/// gobject_gen! {
///     class Foo {
///         field_one: Cell<u32>,
///         field_two: Cell<u16>,
///         ...
///         last_field: Cell<u8>
///     }
/// }
/// ```
///
/// # Declaring methods
///
/// FIXME
///
/// # Declaring signals
///
/// FIXME
///
/// # ABI considerations
///
/// FIXME
///
/// # Necessary imports
///
/// The generated code depends on external crates which you must put in your `Cargo.toml`:
///
/// * The `glib` crate and its macros.
/// * The `gobject_gen` crate, declaring `proc_macro` use.
///
/// You can put this at the top of your crate's main file:
///
/// ```norun
/// #![feature(proc_macro)]
/// extern crate gobject_gen;
///
/// #[macro_use]
/// extern crate glib;
///
/// use gobject_gen::gobject_gen;
/// ```
///
#[proc_macro]
pub fn gobject_gen(input: TokenStream) -> TokenStream {
    let ast_program =
        match parser::parse_program(input) {
            Ok(p) => p,
            Err(e) => {
                let desc = e.to_string();

                return quote! {
                    compile_error!(#desc);
                }.into();
            }
        };

    let result: Result<quote::Tokens> = (|| {
        let program = hir::Program::from_ast_program(&ast_program)?;
        gen::classes(&program)
    })();

    match result {
        Ok(tokens) => {
            let mut config: rustfmt::config::Config = Default::default();
            let mut out: Vec<u8> = vec![];
            config.set().write_mode(rustfmt::config::WriteMode::Plain);
            config.set().error_on_line_overflow(false);
            let stream: String = tokens.to_string().into();
            match rustfmt::format_input(rustfmt::Input::Text(stream), &config, Some(&mut out)) {
                Ok(_) => {
                    let output = String::from_utf8(out).unwrap();
                    println!("/********************************************************************************/\n{}", output);
                    tokens.into()
                }
                Err(e) => error_to_compile_error(&e.0),
            }
        }
        Err(e) => error_to_compile_error(&e),
    }
}

fn error_to_compile_error<E: Error>(e: &E) -> TokenStream {
    let desc = e.description();
    let tokens = quote! {
        compile_error!(#desc);
    };

    tokens.into()
}

#[proc_macro]
pub fn testme(input: TokenStream) -> TokenStream {
    checking::tests::run();
    glib_utils::tests::run();
    hir::tests::run();
    parser::tests::run();
    return input;
}
